'use strict';

// ----------
// Event handlers
// ----------
function dragHandler(e) {
    DragDrop.current.onDrag(e);
}

function releaseHandler(e) {
    DragDrop.current.onReleaseDragHandle(e);
}

// ----------
// Registered DragDrop instances
// ----------
let instances = [];

/**
 * An instance that allows for elements to be dragged and dropped, using pure JavaScript
 */
class DragDrop {
    /**
     * Gets all instances
     *
     * @returns {Array} instances
     */
    static getInstances() {
        return instances;
    }

    /**
     * Destroys a DragDrop instance
     *
     * @param {HTMLelement} element
     */
    static destroy(element) {
        for(let i in instances) {
            let instance = instances[i];

            if(instance.element == element) {
                instance.removeListeners();            
                instances.splice(i, 1);
                break;
            }
        }
    }

    /**
     * Checks whether 2 rects intersect
     *
     * @param {Rect} r1
     * @param {Rect} r2
     *
     * @returns {Boolean} intersects
     */
    static intersectsRect(r1, r2) {
        return (
            r1.left < r2.right &&
            r1.right > r2.left &&
            r1.top < r2.bottom &&
            r1.bottom > r2.top
        ); 
    }

    /**
     * Gets elements stack by position
     *
     * @param {Number} x
     * @param {Number} y
     *
     * @returns {Array} stack
     */
    static getElementStack(x, y) {
        let stack = [];
        let el = document.elementFromPoint(x, y);
        let handbrake = 0;

        while(el && el != document.body && handbrake < 20) {
            stack[stack.length] = el;
            el.style.display = 'none';
            handbrake++;

            el = document.elementFromPoint(x, y);
        }

        for(let i in stack) {
            stack[i].style.display = null;
        }

        return stack;
    }

    /**
     * Sorts an array on elements by z proximity to the cursor
     *
     * @param {Array} elements
     * @param {Number} x
     * @paraa {Number} y
     *
     * @return {Array} ranking
     */
    static sortByZProximity(elements, x, y) {
        if(!elements) {
            throw new Error('sortByZProximity: Elements array is null');
        }

        if(elements instanceof NodeList) {
            throw new Error('sortByZProximity: Elements array is a NodeList');
        }

        let result = [];
        let stack = DragDrop.getElementStack(x, y);

        for(let i in stack) {
            if(elements.indexOf(stack[i]) > -1) {
                result[result.length] = stack[i];
            }
        } 

        return result;
    }

    /**
     * Constructs a new instance
     *
     * @param {HTMLElement} element
     * @param {Object} config
     */
    constructor(element, config) {
        let instance = this;

        // Register this instance
        instances.push(instance);

        // Init element
        this.element = element;
        this.element.setAttribute('data-dragdrop-enabled', 'true');

        // Init listener array
        this.listeners = [];

        // Adopt config
        config = config || {};
        
        this.config = {
            dragThreshold: 2,
            dragScrollSpeed: 5,
            dropContainerSelector: '',
            dropContainers: [],
            lockY: false,
            lockX: false,
            onDrag: function() {},
            onBeginDrag: function() {},
            onEndDrag: function() {}
        };

        for(let k in config) {
            this.config[k] = config[k];
        }

        // Detect initial click
        function downHandler(mousedownEvent) {
            mousedownEvent.stopPropagation();

            if(mousedownEvent.which == 1) {
                mousedownEvent.preventDefault();

                let dragFrames = 0;

                // Detect initial move
                function moveHandler(mousemoveEvent) {
                    dragFrames++;

                    if(dragFrames >= instance.config.dragThreshold) {
                        instance.onMoveDragHandle(mousemoveEvent); 

                        instance.off(instance.element, 'mousemove', moveHandler);
                        instance.off(document, 'mouseup', upHandler);
                    }
                }

                // Detect immediate pointer release
                function upHandler(upEvent) {
                    instance.off(instance.element, 'mousemove', moveHandler);
                    instance.off(document, 'mouseup', upHandler);
                }

                instance.on(instance.element, 'mousemove', moveHandler);
                instance.on(document, 'mouseup', upHandler);
            }
        }

        // Add pointer event
        this.on(this.element, 'mousedown', downHandler);
    }

    /**
     * Register listener
     *
     * @param {HTMLElement} element
     * @param {String} event
     * @param {Function} handler
     */
    on(element, event, handler) {
        element.addEventListener(event, handler);

        this.listeners.push({
            element: element,
            event: event,
            handler: handler
        });
    }

    /**
     * Unregister listener
     *
     * @param {HTMLElement} element
     * @param {String} event
     * @param {Function} handler
     */
    off(element, event, handler) {
        element.removeEventListener(event, handler);

        for(let i in this.listeners) {
            let listener = this.listeners[i];
        
            if(listener.element == element && listener.event == event && listener.handler == handler) {
                this.listeners.splice(i, 1);
                break;
            }
        }
    }

    /**
     * Removes all event listeners
     */
    removeListeners() {
        for(let i in this.listeners) {
            let listener = this.listeners[i];

            listener.element.removeEventListener(listener.event, listener.handler);
        }

        this.listeners = [];
    }

    /**
     * Gets all drop containers
     *
     * @returns {Array} containers
     */
    updateDropContainers() {
        DragDrop.currentDropContainers = [];
        
        // An array of elements are specified
        if(this.config.dropContainers && this.config.dropContainers.length > 0) {
            DragDrop.currentDropContainers = this.config.dropContainers;

        // A selector is specified
        } else if(this.config.dropContainerSelector) {
            DragDrop.currentDropContainers = document.querySelectorAll(this.config.dropContainerSelector);

        // Nothing was specified, use immediate parent
        } else {
            DragDrop.currentDropContainers = [ this.element.parentElement ];
        }

        // Convert NodeList to Array
        if(DragDrop.currentDropContainers instanceof NodeList) {
            let array = [];
            let nodeList = DragDrop.currentDropContainers;

            for(let i = nodeList.length; i--; array.unshift(nodeList[i]));

            DragDrop.currentDropContainers = array;
        }
                
        // If the element itself was found, filter it out
        DragDrop.currentDropContainers = DragDrop.currentDropContainers.filter((dropContainer) => {
            let isSelf = dropContainer == this.element || dropContainer.parentElement == this.element;

            if(isSelf) {
                return false;
            } else {
                dropContainer.dataset.dragdropDropContainer = true;
                return true;
            }
        });
    }

    /**
     * Event: Move drag handle
     *
     * @param {Event} e
     */
    onMoveDragHandle(e) {
        e.preventDefault();
        e.stopPropagation();
       
        DragDrop.current = this;

        // Prevent overlapping mouse interaction on body
        document.body.style.userSelect = 'none';
        document.body.style.pointerAction = 'none';

        // Find parent element with position set to anything but static
        let positionParent = this.element.parentElement;

        while(window.getComputedStyle(positionParent).position == 'static' && positionParent != document.body) {
            positionParent = positionParent.parentElement;
        }

        // Get rects of element and position parent
        let positionParentRect = positionParent.getBoundingClientRect();
        let elementRect = this.element.getBoundingClientRect();

        // Calculate element offset
        let elementOffset = {
            top: elementRect.top - positionParentRect.top,
            left: elementRect.left - positionParentRect.left
        };
        
        // Get computed style
        let computedStyle = window.getComputedStyle(this.element);

        // Calculate pointer offset
        let pointerOffset = {
            top: elementOffset.top - e.pageY,
            left: elementOffset.left - e.pageX
        };

        // Cache the pointer offset
        this.pointerOffset = pointerOffset;

        // Cache the previous parent element
        this.previousParent = this.element.parentElement;

        // Set temporary styling
        this.element.style.position = 'absolute';
        this.element.style.top = elementOffset.top;
        this.element.style.left = elementOffset.left;
        this.element.style.width = elementRect.width;
        this.element.style.height = elementRect.height;
        this.element.style.zIndex = 999;

        // Cache drop containers
        this.updateDropContainers();

        // Insert placeholder
        let placeholder = document.createElement('DIV');

        placeholder.id = 'dragdrop-placeholder';
        placeholder.style.height = computedStyle.height;
        placeholder.style.width = computedStyle.width;

        this.element.parentElement.insertBefore(placeholder, this.element);

        // Add pointer movement logic
        this.on(document, 'mousemove', dragHandler);

        // Add pointer release logic
        this.on(document, 'mouseup', releaseHandler);

        // Fire begin drag event
        if(typeof this.config.onBeginDrag === 'function') {
            this.config.onBeginDrag(this);
        }
    }

    /**
     * Event: On drag
     *
     * @param {Event} e
     */
    onDrag(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // Apply new styling to element
        if(!this.config.lockY) {
            this.element.style.top = e.pageY + this.pointerOffset.top;
        }
        
        if(!this.config.lockX) {
            this.element.style.left = e.pageX + this.pointerOffset.left;
        }

        // Calculate viewport
        let viewport = {
            x: document.scrollLeft,
            y: document.scrollTop,
            w: window.width,
            h: window.height
        };

        // Scroll page if dragging near the top or bottom
        // TODO: Implement for sides too
        if(e.pageY > viewport.y + viewport.h - 100) {
         //   scroll(1 * this.dragScrollSpeed);
        
        } else if(e.pageY < viewport.y + 100) {
          //  scroll(-1 * this.dragScrollSpeed);
        
        }
        
        // Fire drag event
        if(typeof this.config.onDrag === 'function') {
            this.config.onDrag(this);
        }

        // Scan for drop containers
        let elementRect = this.element.getBoundingClientRect();
        
        elementRect.center = elementRect.left + elementRect.width / 2;
        elementRect.middle = elementRect.top + elementRect.height / 2;
        
        // Use array of drop containers sorted by their "proximity" to the pointer on the Z axis
        let hoveredDropContainers = DragDrop.sortByZProximity(DragDrop.currentDropContainers, elementRect.center, elementRect.middle);
        let foundDropContainer;

        // We only need the first index, as that is the closest to the cursor
        if(hoveredDropContainers.length > 0) {
            foundDropContainer = hoveredDropContainers[0];
            
            this.onHoverDropContainer(foundDropContainer);
        }

        // Make sure to trigger the leave event on any other drop containers, if they were previously hovered
        for(let i = 0; i < DragDrop.currentDropContainers.length; i++) {
            let dropContainer = DragDrop.currentDropContainers[i];

            if(dropContainer != foundDropContainer && dropContainer.dataset.dragdropHovering) {
                this.onLeaveDropContainer(dropContainer, e);
            }
        }
    }

    /**
     * Event: On release drag handle
     *
     * @param {Event} e
     */
    onReleaseDragHandle(e) {
        e.preventDefault();
        e.stopPropagation();

        DragDrop.current = null;

        // Remove pointer events
        this.off(document, 'mousemove', dragHandler);
        this.off(document, 'mouseup', releaseHandler);
   
        // Grab hovered drop container
        let hoveredDropContainer = document.querySelector('*[data-dragdrop-drop-container="true"][data-dragdrop-hovering="true"]');

        // Remove drop container events
        for(let i = 0; i < DragDrop.currentDropContainers.length; i++) {
            let dropContainer = DragDrop.currentDropContainers[i];

            delete dropContainer.dataset.dragdropDropContainer;
            delete dropContainer.dataset.dragdropHovering;
        }

        // Get placeholder
        let placeholder = document.getElementById('dragdrop-placeholder');
        
        // Set new parent
        // NOTE: Somehow this can delete the inner HTML of an element. Why?
        placeholder.parentElement.insertBefore(this.element, placeholder);

        // Remove placeholder
        placeholder.parentElement.removeChild(placeholder);   

        // Remove temporary styling
        document.body.removeAttribute('style');
        this.element.removeAttribute('style');
        
        // Add back the grab cursor style
        this.element.style.cursor = 'grab';

        // Remove cached variables
        this.pointerOffset = null;
        this.previousParent = null;
        this.dragHandler = null;
        
        // Fire end drag event
        if(typeof this.config.onEndDrag === 'function') {
            this.config.onEndDrag(this, hoveredDropContainer);
        }
    }

    /**
     * Event: Hover drop container
     *
     * @param {HTMLElement} dropContainer
     * @param {Event} e
     */
    onHoverDropContainer(dropContainer, e) {
        dropContainer.dataset.dragdropHovering = true;
        
        let elementRect = this.element.getBoundingClientRect();
        let placeholder = document.getElementById('dragdrop-placeholder');
        let childNodes = dropContainer.querySelectorAll('*[data-dragdrop-enabled="true"]');

        if(dropContainer.dataset.dragdropUnsorted) {
            // Do nothing so far

        } else if(childNodes.length < 1) {
            dropContainer.appendChild(placeholder);

        } else {
            for(let i = 0; i < childNodes.length; i++) {
                let child = childNodes[i];
                let childRect = child.getBoundingClientRect();

                // If we're dropping onto a new parent drop container,
                // set pointer events of children to none,
                // so they don't interfere with drop container selection
                if(dropContainer != this.previousParent) {
                    child.style.pointerEvents = 'none';
                }

                childRect.center = childRect.left + childRect.width / 2;
                childRect.middle = childRect.top + childRect.height / 2;

                if(this.config.lockX) {
                    if(elementRect.top > childRect.top && elementRect.top < childRect.bottom) {
                        child.parentElement.insertBefore(placeholder, child.nextSibling);
                        break;
                    
                    } else if(elementRect.top < childRect.top && elementRect.bottom > childRect.top) {
                        child.parentElement.insertBefore(placeholder, child);
                        break;

                    }
                
                } else if(this.config.lockY) {
                    if(elementRect.left > childRect.left && elementRect.left < childRect.right) {
                        child.parentElement.insertBefore(placeholder, child.nextSibling);
                        break;

                    } else if(elementRect.left < childRect.left && elementRect.right > childRect.left) {
                        child.parentElement.insertBefore(placeholder, child);
                        break;
                    }

                } else {
                    if(DragDrop.intersectsRect(elementRect, childRect) && child.nextSibling) {
                        child.parentElement.insertBefore(placeholder, child.nextSibling);
                        break;
                    }
                }
            }
        }
    }
    
    /**
     * Event: Leave drop container
     *
     * @param {HTMLElement} dropContainer
     * @param {Event} e
     */
    onLeaveDropContainer(dropContainer, e) {
        dropContainer.removeAttribute('data-dragdrop-hovering');
        
        let childNodes = dropContainer.querySelectorAll('*[data-dragdrop-enabled="true"]');
        
        for(let i = 0; i < childNodes.length; i++) {
            let child = childNodes[i];
            
            //  Remove custom pointer events style
            child.style.pointerEvents = null;
        }
    }
}

window.DragDrop = DragDrop;

if(typeof jQuery !== 'undefined') {
    jQuery.fn.extend({
        exodragdrop: function(config) {
            return this.each(function() {
                if(config == 'destroy') {
                    DragDrop.destroy(this);
                } else {
                    new DragDrop(this, config); 
                }
            });
        }
    });
}
