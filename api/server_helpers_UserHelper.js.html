<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: server/helpers/UserHelper.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: server/helpers/UserHelper.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

// Libs
let nodemailer = require('nodemailer');
let crypto = require('crypto');
let fs = require('fs');
let xoauth2 = require('xoauth2');

let User = require('../models/User');

/**
 * A helper class for managing and getting information about CMS users
 */
class UserHelper {
    /**
     * Initialises this helper
     */
    static init() {
        ConfigHelper.get('mail')
        .then((cfg) => {
            this.mailConfig = cfg;
            this.cachedAccessToken = this.mailConfig.accessToken;
        })
        .catch((e) => {
            debug.log('There was an error reading mail config: ' + e.message, this);
        });
    }

    /**
     * Sends an email
     *
     * @param {Object} mailOptions
     *
     * @returns {Promise} Promise
     */
    static sendEmail(mailOptions) {
        if(!this.mailConfig) {
            return Promise.reject(new Error('Email services are not configured for this instance'));
        }

        return new Promise((resolve, reject) => {
            let generator = xoauth2.createXOAuth2Generator({
                user: this.mailConfig.user,
                clientId: this.mailConfig.clientId,
                clientSecret: this.mailConfig.clientSecret,
                refreshToken: this.mailConfig.refreshToken,
                accessToken: this.cachedAccessToken
            });
            
            generator.on('token', (res) => {
                this.cachedAccessToken = res.accessToken;
            });

            let mailTransport = nodemailer.createTransport({
                service: this.mailConfig.service,
                auth: {
                    xoauth2: generator
                }
            });

            mailTransport.sendMail(mailOptions, (err, info) => {
                if(err){
                    reject(new Error(err));
                
                } else {
                    resolve('Message sent: ' + info.response);
                
                }
            });

        });
    }


    /**
     * Sends a welcome message
     *
     * @param {String} email
     * @param {String} project
     *
     * @returns {Promise} Promise
     */
    static invite(email, project) {
        if(!this.mailConfig) {
            return Promise.reject(new Error('Email services are not configured for this instance'));
        }

        let token = crypto.randomBytes(10).toString('hex');

        let mailOptions = {
            from: '"' + this.mailConfig.displayName + '" &lt;' + this.mailConfig.email + '>',
            to: email,
            subject: 'Welcome to HashBrown',
            html: '&lt;p>You have been kindly invited to join a HashBrown instance.&lt;/p>&lt;p>Please go to this URL to activate your account: &lt;br />' + this.mailConfig.host + '/login?inviteToken=' + token
        };

        let user = User.create();

        user.inviteToken = token;
        user.email = email;
        user.scopes = {};

        if(project) {
            user.scopes[project] = [];
        }
        
        return this.sendEmail(mailOptions)
        .then((msg) => { 
            return MongoHelper.insertOne(
                'users',
                'users',
                user.getObject()
            ).then(() => {
                debug.log('Created new user "' + email + '" successfully', this);
                 
                return Promise.resolve(msg);
            });
        });
    }

    /**
     * Finds a User by username
     *  
     * @param {String} username
     *
     * @returns {Promise(User)} user
     */
    static findUser(username) {
        return MongoHelper.findOne(
            'users',
            'users',
            {
                username: username
            }
        ).then((user) => {
            return new Promise((resolve, reject) => {
                if(!user || Object.keys(user).length &lt; 1) {
                    reject(new Error('No user "' + username + '" found'));
                } else {
                    resolve(new User(user));
                }
            });
        });
    }

    /**
     * Revokes all User tokens
     *
     * @returns {Promise} promise
     */
    static revokeTokens(username) {
        return findUser(username)
        .then((user) => {
            user.tokens = [];

            UserHelper.updateUser(username, user.getObject());
        });
    }

    /**
     * Logs in a User
     *
     * @param {String} username
     * @param {String} password
     * @param {Boolean} persist
     *
     * @returns {Promise} Token
     */
    static loginUser(username, password, persist) {
        debug.log('Attempting login for user "' + username + '"...', this);

        return this.findUser(username)
        .then((user) => {
            if(user.validatePassword(password)) {
                let token = user.generateToken(persist);
               
                user.cleanUpTokens();

                return this.updateUser(username, user.getObject())
                .then(() => {
                    debug.log('User "' + username + '" logged in with token "' + token + '"', this);
                    return Promise.resolve(token);
                });
            } else {
                return Promise.reject(new Error('Invalid password'));
            }
        });
    }
    
    /**
     * Logs out a User
     *
     * @param {String} token
     *
     * @returns {Promise} Result
     */
    static logoutUser(token) {
        debug.log('Logging out user with "' + token + '"...', this);

        return this.findToken(token)
        .then((user) => {
            user.removeToken(token);

            return this.updateUser(user.username, user.getObject())
            .then(() => {
                debug.log('User "' + user.username + '" logged out', this);

                return Promise.resolve();
            });
        });
    }

    /**
     * Finds a token
     *  
     * @param {String} token
     *
     * @returns {Promise} User
     */
    static findToken(token) {
        return MongoHelper.find(
            'users',
            'users',
            {}
        )
        .then((users) => {
            for(let u of users) {
                let user = new User(u);
                
                let isValid = user.validateToken(token);

                if(isValid) {
                    return Promise.resolve(user);
                }
            }

            return Promise.resolve(null);
        });
    }
    
    /**
     * Finds an invite token
     *  
     * @param {String} inviteToken
     *
     * @returns {Promise} User
     */
    static findInviteToken(inviteToken) {
        return MongoHelper.findOne(
            'users',
            'users',
            {
                inviteToken: inviteToken
            }
        ).then((user) => {
            return new Promise((resolve, reject) => {
                if(user &amp;&amp; Object.keys(user).length > 0) {
                    resolve(new User(user));
                
                } else {
                    reject(new Error('Invite token "' + inviteToken + '" could not be found'));

                }
            });  
        });
    }
    
    /**
     * Removes a User
     *
     * @param {String} id
     *
     * @returns {Promise} Promise
     */
    static removeUser(id) {
        return MongoHelper.removeOne(
            'users',
            'users',
            {
                id: id
            }
        ).then(() => {
            debug.log('Deleted user "' + id + '" successfully', this);
           
            return Promise.resolve();
        });
    }

    /**
     * Removes a Project scope from a User object
     *
     * @param {String} id
     * @param {String} scope
     *
     * @returns {Promise} Promise
     */
    static removeUserProjectScope(id, scope) {
        let user;
        let project;
        
        return ProjectHelper.getProject(scope) 
        .then((result) => {
            project = result;

            if(project.users.length &lt; 2) {
                return new Promise((resolve, reject) => {
                    reject(new Error('The last user can\'t be removed from a project. If you want to delete the project, please do so explicitly'));
                });
            
            } else {
                return MongoHelper.findOne('users', 'users', { id: id });
            }
        })
        .then((result) => {
            user = result;

            debug.log('Removing user "' + user.username + '" from project "' + project.name + '"', this);

            delete user.scopes[scope];
            
            return MongoHelper.updateOne('users', 'users', { id: id }, user);
        });
    }
    
    /**
     * Adds a Project scope to a User object
     *
     * @param {String} id
     * @param {String} project
     * @param {Array} scopes
     *
     * @returns {Promise} Promise
     */
    static addUserProjectScope(id, project, scopes) {
        return MongoHelper.findOne('users', 'users', { id: id })
        .then((user) => {
            user.scopes  = user.scopes || {};

            user.scopes[project] = scopes || [];

            return this.updateUserById(id, user);
        });
    }

    /**
     * Activates an invited User
     *
     * @param {String} username
     * @param {String} password
     * @param {String} fullName
     * @param {String} inviteToken
     *
     * @returns {Promise} Login token
     */
    static activateUser(username, password, fullName, inviteToken) {
        let newUser;

        // Username check
        if(!username || username.length &lt; 4) {
            return Promise.reject(new Error('Usernames must be at least 4 characters'));
        }
        
        // Password check
        if(!password || password.length &lt; 4) {
            return Promise.reject(new Error('Passwords must be at least 4 characters'));
        }
        
        return UserHelper.findInviteToken(inviteToken)
        .then((user) => {
            user.fullName = user.fullName || fullName;
            user.username = username;
            user.setPassword(password);
            user.inviteToken = '';

            newUser = user;

            return MongoHelper.findOne(
                'users',
                'users',
                {
                    username: username
                }
            );
        }).then((existingUser) => {
            if(!existingUser) {
                return UserHelper.updateUserById(newUser.id, newUser.getObject());
            
            } else {
                return new Promise((resolve, reject) => {
                    reject(new Error('Username "' + username + '" is taken'));
                });

            }
        })
        .then(() => {
            return UserHelper.loginUser(username, password);
        });
    }

    /**
     * Creates a User
     *
     * @param {String} username
     * @param {String} password
     * @param {Boolean} admin
     * @param {Object} scopes
     *
     * @returns {Promise} promise
     */
    static createUser(username, password, admin, scopes) {
        if(!username) {
            return new Promise((resolve, reject) => {
                reject(new Error('Username was not provided'));
            });
        }
        
        if(!password) {
            return new Promise((resolve, reject) => {
                reject(new Error('Password was not provided'));
            });
        }
        
        let user = User.create(username, password);

        user.isAdmin = admin || false;
        user.scopes = scopes || {};

        return MongoHelper.findOne(
            'users',
            'users',
            {
                username: username
            }
        ).then((found) => {
            let foundUser = new User(found);

            // User wasn't found, create
            if(!found) {
                debug.log('Creating user "' + username + '"...', this);
                
                return MongoHelper.insertOne(
                    'users',
                    'users',
                    user.getObject()
                ).then(() => {
                    debug.log('Created user "' + username + '" successfully', this);
                   
                    return new Promise((resolve) => {
                        resolve(user);
                    }); 
                });

            // Username matches an existing user
            } else {
                return new Promise((resolve, reject) => {
                    reject(new Error('Username "' + username + '" is taken'));
                });
            }
        });
    }

    /**
     * Makes a User an admin
     *
     * @param {String} username
     *
     * @returns {Promise} Promise
     */
    static makeUserAdmin(username) {
        return this.getUser(username)
        .then((user) => {
            user.isAdmin = true;

            return this.updateUser(username, user);
        });
    }

    /**
     * Gets a list of all users
     *
     * @param {String} project
     *
     * @returns {Promise} Array of User objects
     */
    static getAllUsers(project) {
        let query = {};

        // Build query for project scope
        if(project) {
            debug.log('Getting all users with project "' + project + '" in scope...', this, 3);

            let projectScopeQuery = {};
            projectScopeQuery['scopes.' + project] = { $exists: true };

            let isAdminQuery = { isAdmin: true };

            query['$or'] = [
                projectScopeQuery,
                isAdminQuery
            ];

        } else {
            debug.log('Getting all users...', this, 3);
        }

        return MongoHelper.find(
            'users',
            'users',
            query,
            {
                tokens: 0,
                password: 0
            }
        )
        .then((users) => {
            let userModels = [];

            for(let user of users) {
                userModels.push(new User(user));
            }  

            return new Promise((resolve) => {
                resolve(userModels);
            });
        });
    }
    
    /**
     * Gets a single User by id
     *
     * @param {String} id
     *
     * @returns {Promise} User object
     */
    static getUserById(id) {
        let query = {};

        debug.log('Getting user "' + id + '"...', this, 3);

        return MongoHelper.findOne(
            'users',
            'users',
            {
                id: id
            },
            {
                tokens: 0,
                password: 0
            }
        );
    }
    
    /**
     * Gets a single User
     *
     * @param {String} username
     *
     * @returns {Promise} User object
     */
    static getUser(username) {
        let query = {};

        debug.log('Getting user "' + username + '"...', this, 3);

        return MongoHelper.findOne(
            'users',
            'users',
            {
                username: username
            },
            {
                tokens: 0,
                password: 0
            }
        );
    }

    /**
     * Cleans up expired tokens
     *
     * @returns {Promise} promise
     */
    static cleanUpTokens(username) {
        return this.findUser(username)
        .then((user) => {
            if(user) {
                user.cleanUpTokens();

                return this.updateUser(username, user.getObject());

            } else {
                return new Promise((resolve, reject) => {
                    reject(new Error('No user by username "' + username + '"'));
                });
            
            }
        });
    }
    
    /**
     * Updates a User by id
     *
     * @param {String} id
     * @param {Object} properties
     *
     * @returns {Promise} Promise
     */
    static updateUserById(id, properties) {
        if(typeof properties.password === 'string') {
            properties.password = User.createPasswordHashSalt(properties.password);
        }
        
        return MongoHelper.mergeOne(
            'users',
            'users',
            {
                id: id
            },
            properties
        ).then(() => {
            debug.log('Updated user "' + id + '" successfully', this);
            
            return Promise.resolve(new User(properties));
        });
    }

    /**
     * Updates a User
     *
     * @param {String} username
     * @param {Object} properties
     *
     * @returns {Promise} promise
     */
    static updateUser(username, properties) {
        if(typeof properties.password === 'string') {
            properties.password = User.createPasswordHashSalt(properties.password);
        }

        return MongoHelper.mergeOne(
            'users',
            'users',
            {
                username: username
            },
            properties
        ).then(() => {
            debug.log('Updated "' + username + '" successfully', this);
        });
    }
}

UserHelper.init();

module.exports = UserHelper;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ApiController.html">ApiController</a></li><li><a href="AppHelper.html">AppHelper</a></li><li><a href="BackupHelper.html">BackupHelper</a></li><li><a href="BooleanEditor.html">BooleanEditor</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ConnectionController.html">ConnectionController</a></li><li><a href="Content.html">Content</a></li><li><a href="ContentController.html">ContentController</a></li><li><a href="ContentReferenceEditor.html">ContentReferenceEditor</a></li><li><a href="ContentSchema.html">ContentSchema</a></li><li><a href="ContentSchemaReferenceEditor.html">ContentSchemaReferenceEditor</a></li><li><a href="Controller.html">Controller</a></li><li><a href="DateEditor.html">DateEditor</a></li><li><a href="DropdownEditor.html">DropdownEditor</a></li><li><a href="Entity.html">Entity</a></li><li><a href="FieldSchema.html">FieldSchema</a></li><li><a href="Form.html">Form</a></li><li><a href="FormEditor.html">FormEditor</a></li><li><a href="FormHelper.html">FormHelper</a></li><li><a href="InfoEditor.html">InfoEditor</a></li><li><a href="JSONEditor.html">JSONEditor</a></li><li><a href="LanguageEditor.html">LanguageEditor</a></li><li><a href="Media.html">Media</a></li><li><a href="MediaReferenceEditor.html">MediaReferenceEditor</a></li><li><a href="MessageModal.html">MessageModal</a></li><li><a href="MongoHelper.html">MongoHelper</a></li><li><a href="NavbarMain.html">NavbarMain</a></li><li><a href="NumberEditor.html">NumberEditor</a></li><li><a href="ProjectEditor.html">ProjectEditor</a></li><li><a href="ProjectHelper.html">ProjectHelper</a></li><li><a href="ProvidersSettings.html">ProvidersSettings</a></li><li><a href="RequestHelper.html">RequestHelper</a></li><li><a href="ResourceReferenceEditor.html">ResourceReferenceEditor</a></li><li><a href="RichTextEditor.html">RichTextEditor</a></li><li><a href="ScheduleController.html">ScheduleController</a></li><li><a href="ScheduleHelper.html">ScheduleHelper</a></li><li><a href="Schema.html">Schema</a></li><li><a href="SchemaController.html">SchemaController</a></li><li><a href="SchemaEditor.html">SchemaEditor</a></li><li><a href="SchemaHelper.html">SchemaHelper</a></li><li><a href="StringEditor.html">StringEditor</a></li><li><a href="StructEditor.html">StructEditor</a></li><li><a href="SyncEditor.html">SyncEditor</a></li><li><a href="SyncHelper.html">SyncHelper</a></li><li><a href="TagsEditor.html">TagsEditor</a></li><li><a href="Task.html">Task</a></li><li><a href="Template.html">Template</a></li><li><a href="TemplateEditor.html">TemplateEditor</a></li><li><a href="TemplateReferenceEditor.html">TemplateReferenceEditor</a></li><li><a href="UpdateHelper.html">UpdateHelper</a></li><li><a href="UrlEditor.html">UrlEditor</a></li><li><a href="UserHelper.html">UserHelper</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon May 29 2017 21:20:48 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
