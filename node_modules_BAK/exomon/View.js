'use strict';

/**
 * Generates a new GUID
 */
function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
}

let instances = [];

/**
 * Helper class for getting instances of Views
 *
 * @class ViewHelper
 */
class ViewHelper {
    static getAll(type) {
        let results = [];

        if(type) {
            for(let i in instances) {
                let instance = instances[i];
                let name = instance.name;

                if(name == type) {
                    results.push(instance);
                }
            }
        } else {
            results = instances;
        }

        return results;
    }

    static get(type) {
        let results = ViewHelper.getAll(type);
        let view = results.length > 0 ? results[0] : null;

        return view;
    }

    static clear(type) {
        for(let guid in instances) {
            let instance = instances[guid];
            let name = instance.constructor.name;
            
            if(!type || name == type) {
                instance.remove();
            }
        }
    }

    static removeAll(type) {
        for(let view of ViewHelper.getAll(type)) {
            view.remove();
        }
    }
}

window.ViewHelper = ViewHelper;

/**
 * View class
 *
 * @class View
 *
 * @param {Object} params
 */
class View {
    constructor(params) {
        this.name = this.constructor.name;
        this.guid = guid();
        this.events = {};

        this.adopt(params);

        instances[this.guid] = this;
    }

    /**
     * Gets the name of this View
     */
    getName() {
        let name = this.constructor.toString();
        name = name.substring('function '.length);
        name = name.substring(0, name.indexOf('('));

        return name;
    }

    /**
     * Init
     */
    init() {
        this.prerender();
        this.render();
        this.postrender();
        
        let element = (this.element || this.$element[0]);
        
        element.addEventListener('DOMNodeRemovedFromDocument', () => {
            // Wait a few cycles before removing, as the element might just have been relocated
            setTimeout(() => {
                let element = (this.element || this.$element[0]);
                
                if(!element || !element.parentNode) {
                    this.remove();
                }
            }, 10);
        });

        this.trigger('ready', this);
        this.isReady = true;
    }

    /**
     * Shorthand for .on('ready')
     */
    ready(callback) {
        if(this.isReady) {
            callback(this);
        } else {
            this.on('ready', callback);
        }
    }

    /**
     * Adopts values
     *
     * @param {Object} values
     */
    adopt(params) {
        for(let k in params) {
            this[k] = params[k];
        }

        return this;
    }

    /**
     * Runs before render
     */
    prerender() {

    }

    /**
     * Renders this view
     */
    render() {
        let output;

        if(typeof this.template === 'function') {
            output = this.template.call(this, this);
        }

        if(output) {
            // jQuery
            if(typeof jQuery !== 'undefined') {
                if(this.$element) {
                    this.$element.html(output.children());
                } else {
                    this.$element = output;
                }
           
            // Native JavaScript
            } else {
                if(this.element) {
                    this.element.innerHTML = output.innerHTML;
                } else {
                    this.element = output;
                }

            }
        }
    }

    /**
     * Runs after render
     */
    postrender() {

    }

    /**
     * Removes the view from DOM and memory
     */
    remove(timeout) {
        if(!this.destroyed) {
            this.destroyed = true;

            setTimeout(() => {
                this.trigger('remove');

                // jQuery
                if(typeof jQuery !== 'undefined' && this.$element && this.$element.length > 0) {
                    this.$element.remove();

                // Native JavaScript
                } else if(this.element && this.element.parentElement) {
                    this.element.parentElement.removeChild(this.element);

                }

                delete instances[this.guid];
            }, timeout || 0 );
        }
    }

    /**
     * Call an event (for internal use)
     */
    call(callback, data, ui) {
        callback(data, ui, this);
    }

    /**
     * Trigger an event
     */
    trigger(e, obj) {
        if(this.events[e]) {
            if(typeof this.events[e] === 'function') {
                this.events[e](obj);
            } else {
                for(let i in this.events[e]) {
                    if(this.events[e][i]) {
                        this.events[e][i](obj);
                    }
                }
            }
        }
    }

    /**
     * Bind an event
     */
    on(e, callback) {
        let view = this;

        // No events registered, register this as the only event
        if(!this.events[e]) {
            this.events[e] = function(data) { view.call(callback, data, this); };
        
        // Events have already been registered, add to callback array
        } else {
            // Only one event is registered, so convert from a single reference to an array
            if(!this.events[e].length) {
                this.events[e] = [
                    this.events[e]
                ];
            }
           
            // Insert the event call into the array 
            this.events[e].push(function(data) { view.call(callback, data, this); });
        }
    }

    /**
     * Check if event exists
     */
    hasEvent(name) {
        for(let k in this.events) {
            if(k == name) {
                return true;
            }
        }

        return false;
    }

    /**
     * Fetch model data
     */
    fetch() {
        let view = this;

        function getModel() {
            // Get model from URL
            if(!view.model && typeof view.modelUrl === 'string') {
                var request = new XMLHttpRequest();
                request.open('GET', view.modelUrl, true);

                request.onload = function() {
                    if (request.status >= 200 && request.status < 400) {
                        // Success!
                        var data = JSON.parse(request.responseText);
                        
                        view.model = data;
                        
                        view.init();
                    } else {
                        // We reached our target server, but it returned an error
                        throw new Error('Couldn\'t fetch model data');
                    }
                };

                request.onerror = function(e) {
                    throw e;
                };

                request.send();
            
            // Get model with function
            } else if(!view.model && typeof view.modelFunction === 'function') {
                view.modelFunction(function(data) {
                    view.model = data;

                    view.init();
                });

            // Just perform the initialisation
            } else {
                view.init();
            }
        }

        // Get the model
        getModel();    
    }
}

window.View = View;
